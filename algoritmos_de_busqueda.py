# -*- coding: utf-8 -*-
"""Algoritmos de busqueda

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11kXapOUTumL6Z3O-ufY4xYPYsdtrCcwk

**Clase Nodo:** Sirve para crear nodos del arbol de busqueda con la informacion pertinente
"""

class Node:
    "A Node in a search tree."
    def __init__(self, state, parent=None, action=None, path_cost=0,h=0):
        "Esta línea actualiza el diccionario de atributos (__dict__) del objeto Node con los valores pasados como parámetros."
        self.__dict__.update(state=state, parent=parent, action=action, path_cost=path_cost,h=h)
    "define cómo se representa el objeto cuando se imprime en la consola o se utiliza la función repr() en él"
    def __repr__(self): return '<{}>'.format(self.state)
    def __len__(self): return 0 if self.parent is None else (1 + len(self.parent))
    def __lt__(self, other): return self.path_cost < other.path_cost

"""**Entrada o problema de busqueda**"""

import pandas as pd
import numpy as np

# Especifica la ruta de tu archivo Excel
archivo_excel = 'drive/MyDrive/Inteligentes/Algoritmos de busqueda/Problema de busqueda.xlsx'

# Lee el archivo Excel y carga la hoja que contiene la tabla (puedes especificar el nombre de la hoja o el índice)
df = pd.read_excel(archivo_excel, sheet_name='Hoja 1',index_col=0)


# Se busca el estado inicial e inserta informacion en nodo raiz
try:
    # Encuentra la posición del valor buscado en el DataFrame
    fila, columna = (df == "Start").values.nonzero()
    # Imprime la posición del valor encontrado
    root=Node(state=df.columns[columna[0]],h=df.loc[str(df.index[fila[0]]),'h(x)'])
except IndexError:
    print(f"No se encontró el estado inicial en el DataFrame.")

# Se busca los valores de los estados objetivos
try:
    # Encuentra la posición del valor buscado en el DataFrame
    fila, columna = (df == "Goal").values.nonzero()
    # Imprime la posición del valor encontrado
    goalStateValues=df.columns[columna[:]]
except IndexError:
    print(f"No se encontraron estados objetivos.")
print("El valor del estado inicial es: "+ root.state)
print("Los valores de los estados objetivos son: "+ goalStateValues)
print(df)



"""**Solucion al problema de busqueda usando DFS**: Ejecute busqueda en profundidad, teniendo en cuenta que las estados entran a la pila en
orden inverso de su etiqueta, de manera que al extraerlos de la pila saldra el estado con
menor etiqueta. Igualmente, tenga en cuenta que el algoritmo de busqueda previene ciclos
llevando una lista de nodos alcanzados (reached).
"""

stack=[]
alcanzados=[]
stack.append(root)
try:
  popeado=stack.pop()
  alcanzados.append(popeado.state)
  while popeado.state != goalStateValues:
    fila_popeado=df.loc[popeado.state]
    columna = list(fila_popeado[fila_popeado.notna()].index)# estados en los que las celdas no son null en la fila
    if (popeado.state in columna) and (popeado.state!="Goal"):
      columna.remove(popeado.state)
    columna.remove('h(x)')
    if columna:
      for labelState in columna[::-1]:
        nodeToStack=Node(labelState,popeado,None,df.loc[popeado.state,labelState],df.loc[labelState,'h(x)'])
        stack.append(nodeToStack)
    try:
      popeado=stack.pop()
      while popeado.state in alcanzados:
        popeado=stack.pop()
      alcanzados.append(popeado.state)
    except IndexError:
      print("no hay nodos que expandir en el stack, por ende no se puede llegar a un estado objetivo")
  print("se ha llegado al estado objetivo y los estados recorridos para encontrarla son:")
  print(popeado.state,end="")
  while popeado.__len__()!=0:
    print(popeado.parent.state,end="")
    popeado=popeado.parent
except IndexError:
  print("no hay nodos que expandir en el stack, por ende no se puede llegar a un estado objetivo")